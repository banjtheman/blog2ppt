{"title": "How I built a Full Stack Web3 App on the Cloud", "desc": "How I built a Full Stack Web3 App on the Cloud", "cover_image": "downloaded_images/gitgallery_frame.png", "sections": [{"name": "Intro", "elements": [{"elem_type": "text", "data": "As a builder, I am always curious about how to develop applications with emerging technology.  A technology that has captured my attention recently has been non fungible tokens (NFTs). An NFT is a unique digital item that is stored on a blockchain. A common use case is to store digital art as an NFT that can be sold to collectors. I\u2019ve always fostered the idea that code is art. With the resurgent demand for NFTs it provided the perfect opportunity to build a product that can embed code as a art. Thus GitGallery was born, a website that allows you to mint your GitHub commits as an NFT.  This post will dive deep on how I built GitGallery highlighting"}, {"elem_type": "list", "data": ["Smart Contract Development", "Backend API", "User Interface", "Application Deployment"]}]}, {"name": "Overview", "elements": [{"elem_type": "text", "data": "To provide a scalable, cost effective process for minting NFTs I leveraged Polygon  which is a protocol and framework that provides reduced fees needed to run Ethereum based applications."}, {"elem_type": "text", "data": "In addition, the entire web application is deployed on Amazon Web Services (AWS). By leveraging AWS, I was able to create a serverless application that responds to events rather than wasting compute sitting idly if deployed onto a server. With AWS Lambda and API Gateway one million events are free to use each month which provides a cost-effective way to host the application. The following sections will detail the tools and processes I used to develop the smart contract, the backend API (Application Programming Interface) and the user interface. "}]}, {"name": "Smart Contract", "elements": [{"elem_type": "text", "data": "The smart contract I developed provides the ability to create a unique token named GitNFT which is linked to a GitHub commit. The code was developed using the Solidity programming language. I was able to import code developed by OpenZeppelin a firm that provides secure code for blockchain applications. The code implements the NFT standard known as ERC (Ethereum Request for Comment) 721 which provides the functionality to deploy the smart contract to the blockchain and mint NFTs.\n"}, {"elem_type": "code", "data": "pragma solidity ^0.8.0;\n\nimport \"./ERC721Tradable.sol\";\n\n/**\n * @title GitNFT\n * GitNFT - a contract for code GitNFTs.\n */\ncontract GitNFT is ERC721Tradable {\n    uint256 public nextTokenId;\n    address public admin;\n\n    constructor(address _proxyRegistryAddress)\n        public\n        ERC721Tradable(\"GitNFT\", \"GitNFT\", _proxyRegistryAddress)\n    {\n        admin = msg.sender;\n    }\n\n    // only our wallet should be able to mint\n    function mint(address to) external onlyOwner {\n        _safeMint(to, nextTokenId);\n        nextTokenId++;\n    }\n\n    function baseTokenURI() public pure override returns (string memory) {\n        return \"https://www.gitgallery.com/tokenid/\";\n    }\n}\n"}, {"elem_type": "text", "data": "Once the code is written the next step is to deploy the contract to the Polygon blockchain. "}, {"elem_type": "text", "data": "I used the deployment software Truffle with the Ethereum API Infura to compile my contract code and deploy the artifacts to the Polygon blockchain. Here is a code used to deploy the contract to the Polygon Blockchain\n"}, {"elem_type": "code", "data": "const NFT = artifacts.require(\"GitNFT\");\nconst proxyRegistryAddress = process.env.OWNER_ADDRESS\n\n\nmodule.exports = async function (deployer, _network, accounts) {\n  await deployer.deploy(NFT,proxyRegistryAddress, {gas: 5000000});\n  const nft = await NFT.deployed();\n};\n\n"}, {"elem_type": "text", "data": "This transaction required the Polygon token MATIC to pay for the contract fees, which in total cost about 1 cent. Compiling the code also produces an Application Binary Interface (ABI) which is a JavaScript Object Notation (JSON) file that allows for other applications to interact with the contract. "}]}, {"name": "Backend API", "elements": [{"elem_type": "text", "data": "I used Python to develop the business logic needed for GitGallery and used the Flask framework to encode the API endpoints. The 4 major endpoints needed for the application are login, verify, mint, and get items."}]}, {"name": "Login", "elements": [{"elem_type": "text", "data": "By leveraging Auth0 a platform designed to make it easy to login via 3rd party authentication, I created an endpoint that allows users to login via their GitHub account. The code stores the logged in user details via cookies in the current web browser session, to track state from each request. When a user logs out, the browser session clears all cookies."}]}, {"name": "Verify", "elements": [{"elem_type": "text", "data": "To verify a GitHub commit, users enter in the URL of their GitHub commit. By using the GitHub GraphQL API, I created a query that could verify if the user created the commit ID for the given project. Here is the GraphQL query used to verify the author of the commit.\n"}, {"elem_type": "code", "data": "{\n  repository(owner: \"OWNER\", name: \"NAME\") {\n    object(expression: \"COMMIT_ID\") {\n      ... on Commit {\n        author{\n          name\n          user{\n            login\n          }\n        }\n      }\n    }\n  }\n}\n\n"}]}, {"name": "Mint", "elements": [{"elem_type": "text", "data": "Once a commit is verified, the user can mint the commit as an NFT. By using the ABI and the python Ethereum library web3.py the code executes the mint function of the NFT contract. Here is the code used to mint the GitNFT\n"}, {"elem_type": "code", "data": "def web3_mint(userAddress: str):\n    \"\"\"\n    Purpose:\n        mint a token for user on blockchain\n    Args:\n        userAddress - the user to mint for\n    Returns:\n        hash - txn of mint\n        tokenid - token minted\n    \"\"\"\n\n    nonce = w3.eth.get_transaction_count(PUBLIC_KEY)\n\n    # Create the contract function\n    mint_txn = CODE_NFT.functions.mint(userAddress).buildTransaction(\n        {\n            \"chainId\": CHAIN_ID,\n            \"gas\": 10000000,\n            \"gasPrice\": w3.toWei(\"1\", \"gwei\"),\n            \"nonce\": nonce,\n        }\n    )\n\n    signed_txn = w3.eth.account.sign_transaction(mint_txn, private_key=PRIVATE_KEY)\n\n    w3.eth.send_raw_transaction(signed_txn.rawTransaction)\n    hash = w3.toHex(w3.keccak(signed_txn.rawTransaction))\n    receipt = w3.eth.wait_for_transaction_receipt(hash)  \n    hex_tokenid = receipt[\"logs\"][0][\"topics\"][3].hex()  # this is token id in hex\n\n    # convert from hex to decmial\n    tokenid = int(hex_tokenid, 16)\n    logging.info(f\"Got tokenid: {tokenid}\")\nreturn hash, tokenid\n\n\n"}, {"elem_type": "text", "data": "The fee for calling the contract is paid from MATIC I allocated for the project. Since the minting cost is less then a fraction of a penny the process is virtually free and more importantly has no costs to the user. Each minted NFT produces a JSON file with the commit metadata. The metadata is stored in Amazon S3 and DynamoDB."}]}, {"name": "Get Items", "elements": [{"elem_type": "text", "data": "To display Items for a particular user the code creates a DynamoDB query using the selected user as the partition key. The JSON in S3 is used for external platforms such as OpenSea which is a marketplace for NFTs. There is a particular format needed for the data to show correctly in external applications which is handled by S3, while data on GitGallery is rendered from DynamoDB."}]}, {"name": "Deployment", "elements": [{"elem_type": "text", "data": "To deploy the code to the web, I leveraged the Serverless framework. Serverless allows me to create a YAML (YAML Ain't Markup Language) file that specifies all infrastructure and security needed to deploy the Flask application as a docker image. Serverless will deploy the docker image on AWS Lambda with the endpoints mapping to API Gateway, with the necessary Identity and Access Management (IAM) roles to access services such as S3 and DynamoDB."}]}, {"name": "User Interface", "elements": [{"elem_type": "text", "data": "The user interface is a website built using HTML, Bootstrap, JavaScript, jinja2 and JQuery. These tools allowed me to create a user interface that leverages server-side rendering to allow for dynamic routes such as www.gitgallery.com/gallery/{USER_NAME}/minted\n"}, {"elem_type": "code", "data": "@application.route(\"/gallery/<user>/minted\")\ndef minted(user):\n    \"\"\"\n    Purpose:\n        load gallery page\n    Args:\n        N/A\n    Returns:\n        html - gallery html\n    \"\"\"\n    if \"profile\" in session:\n        curr_user = session[\"profile\"]\n    else:\n        curr_user = None\n\n    # check if user exists...\n\n    userdata = users.get_item(Key={\"username\": user})\n    if not \"Item\" in userdata:\n        logging.error(f\"No such user {user}\")\n        return redirect(f\"/\")\n\n    user_metadata = userdata[\"Item\"]\n\n    # get minted items\n    minted_items = get_minted_items(user)\n\n    return render_template(\n        \"gallery.html\",\n        userinfo=curr_user,\n        minted_items=minted_items,\n        user=user,\n        user_metadata=user_metadata,\n    )\n"}, {"elem_type": "text", "data": "In addition, I utilized the ethers.js library to provide a way for users to sign their GitHub commits using their MetaMask Wallet. The MetaMask wallet provides users an interface to interact with the Ethereum blockchain. The following is the front end code used to mint tokens\n"}, {"elem_type": "code", "data": "async function safe_mint(data) {\n                    // console.log(\"safe mint called\")\n\n                    let userAddress = \"\"\n                    try {\n                        userAddress = await walletSigner.getAddress()\n\n                    } catch (error) {\n                        alert(\"Metamask not detected\")\n                        console.log(error)\n                        return\n                    }\n\n                    let username = data[\"username\"]\n                    let ver_url = data[\"verify_url\"]\n                    let ver_date = data[\"status_json\"][\"date\"]\n\n                    // Commint\n                    const base_message = \"Signed on GitGallery\\n\\n\" + username + \" \" + ver_date + \"\\n \" + ver_url\n                    const signature = await walletSigner.signMessage(base_message)\n\n                    var mintObj = {}\n                    mintObj[\"verify_json\"] = data\n                    mintObj[\"signature\"] = signature\n                    mintObj[\"userAddress\"] = userAddress\n\n                    var mintString = JSON.stringify(mintObj)\n\n                    $(\"body\").css(\"opacity\", \".3\");\n                    $(\"#load_spinner\").toggle();\n\n                    $.ajax({\n                        type: \"POST\",\n                        url: \"/mint_token\",\n                        dataType: \"json\",\n                        data: mintString,\n                        contentType: \"application/json\",\n                        success: function (data) {\n                            console.log(\"mint returned\")\n                            console.log(data)\n\n                            $(\"#load_spinner\").toggle();\n                            $(\"body\").css(\"opacity\", \"1\");\n\n\n                            //check for error\n                            if ('error' in data) {\n                                alert(data[\"error\"]);\n                                return -1\n                            }\n\n                            alert(\"Mint Successful\")\n\n                            //passed? reload page?\n                            location.reload()\n                        },\n                        error: function (xhr, textStatus, thrownError, data) {\n                            alert(\"Error: \" + thrownError);\n                            $(\"body\").css(\"opacity\", \"1\");\n                            $(\"#load_spinner\").toggle();\n\n                        }\n                    })\n\n\n                }\n"}]}, {"name": "Conclusion", "elements": [{"elem_type": "text", "data": "Connecting all the dots results in a full stack NFT application with a simple workflow. A user signs in using their GitHub credentials. The user enters in a URL for a GitHub Commit. The system verifies the commit for the user. The user then signs the commit with MetaMask. Finally, the GitHub commit is minted as an NFT and stored in the user\u2019s MetaMask wallet. This workflow allows for the creation of an NFT in less than 30 seconds for free. "}, {"elem_type": "image", "data": "https://dev-to-uploads.s3.amazonaws.com/uploads/articles/9uukxcji7qgsemfdyym7.png", "alt_text": "GitGallery Mint Diagram"}, {"elem_type": "text", "data": "If you itching to build your own NFT project, I've created a hands on workshop that focusing on leveraging these tools to launch your own smart contract."}]}]}